# TODO

- figure out why auto panel generation didn't work
- implement delay-time switch
- smooth knob values (i.e. delay time over a period of 0.5 seconds)

# Explanation

This is a simple delay line with two parameters, built as a plugin for VCVRack using the DaisySP library.

See [here](https://github.com/fablabnk/VaseProtoPlugin/tree/delay_line) for version 1, with more notes and without parameters

- It is a first step towards prototyping a Daisy seed-based audio processing Eurorack module.
- The code is based on the Daisy example [here](https://github.com/electro-smith/DaisyExamples/blob/master/seed/DSP/delayline/delayline.cpp), but with the oscillator and envelope stripped out to create a simple fixed-length delay.
- The next step will be to add modulatable parameters.

# Things I learned building this module...

## Making the .svg panel file

Elements in .svg file should be separated into layers. I separated as follows:

- components (the colour circles representing VCVRack components i.e. input jack sockets, knobs, etc)
- text (as paths, using Object to Path)
- panel (background representing the whole front panel)

## Autogenerating the panel component positions didn't work

When I did it, the panel autogenerated Y values were wrong i.e. in the 200's not below 128. Why was this?

## Setting DelayTime correctly

This was more complex than it at first seemed. I misunderstood how to get the value of params and was treating them like inputs as follows:

```
inputs[PARAM_ONE_PARAM].getVoltage() 
```

When they should be treated like so:

```
params[PARAM_ONE_PARAM].getValue()
```

Inputs range between +-5v, whereas parameters range between the values you initialise them with i.e.

```
configParam(PARAM_ONE_PARAM, 0.f, 1.f, 1.f, "Delay Time (secs)");
```

## Setting short and long delay times with a switch (TODO)

I want to include a switch on the panel which allows switch

when set left/off = min delay time is 0.1 second, max delay time is 1 second
when set right/on = min delay time is 0.5 seconds, max delay time is 5 seconds

## Smoothing Parameters

Parameters can be smoothed as follows i.e. to avoid jumps when turning the knob

```
fonepole(current_delay_, delay_target, .0002f); 
```

However this doesn't help with out delayTime - ideally we should interpolate between delay time values over a large amount of time

I could try this with a large interpolation time. But so far I'm not doing it at all...

## Debugging using std::cout

Is possible! I wanted to check if my delayTime was in the correct range (0.1 to 1.0) using a print statement. I achieved this by

1. At top of .cpp:
```
#include <iostream>
```

2. In process function:
```
std::cout << delayTime << std::endl;
```

Output appears in terminal from where I'm running `./Rack`. You might not get such output if you're running as an installed program on Windows or macOS

## Components can be given 'hoverable' tooltip labels

In DelayParamsProto(), we call various config function, each of which ends with a string which is the tooltip text
```
configParam(PARAM_ONE_PARAM, 0.f, 1.f, 1.f, "Delay Time");
```

## How to use the values from the CV Inputs

I decided to combine them with their corresponding value from the parameter knob. This I did explictly, as there is nothing to handle this under-the-hood as far as I could tell. Here was my approach:

1. We receive the parameter values as input voltage (-5v to +5v) and convert them to -1 to +1, as follows:

```
float paramOne = params[PARAM_ONE_PARAM].getValue() + (inputs[PARAM_ONE_CV_INPUT].getVoltage() / 5.0f);
```

2. Then we clamp them to within 0. - 1. bounds
```
float clampedParamOne = clamp(paramOne, 0.f, 1.f);
```

The clamp functions looks as follows:

```
template<typename T>
const T& clamp(const T& value, const T& low, const T& high) {
    return (value < low) ? low : (value > high) ? high : value;
}
```

3. After this we scale them as necessary, depending on parameter usage e.g. delay time

```
float rangeDelayTimeSecs = maxDelayTimeSecs - minDelayTimeSecs;
float delayTime = (clampedParamOne * rangeDelayTimeSecs) + minDelayTimeSecs;
del.SetDelay(SAMPLE_RATE * delayTime);
```